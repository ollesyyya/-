АЛГОРИТМ: БЫСТРАЯ СОРТИРОВКА (QUICK SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм быстрой сортировки работает по принципу "разделяй и властвуй":

1. ВЫБОР ОПОРНОГО ЭЛЕМЕНТА:
   - Выбирается опорный элемент (pivot), обычно последний элемент массива

2. РАЗДЕЛЕНИЕ МАССИВА:
   - Массив разделяется на три части:
     * LEFT: элементы МЕНЬШЕ опорного
     * MIDDLE: элементы РАВНЫЕ опорному  
     * RIGHT: элементы БОЛЬШЕ опорного

3. РЕКУРСИВНАЯ СОРТИРОВКА:
   - Рекурсивно применяется та же логика к левой и правой частям

4. ОБЪЕДИНЕНИЕ РЕЗУЛЬТАТОВ:
   - Отсортированные части объединяются в порядке: LEFT + MIDDLE + RIGHT

ПРОЦЕСС ПОВТОРЯЕТСЯ до базового случая - когда массив содержит 0 или 1 элемент.

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Опорный элемент: 90
Разделение: [64, 34, 25, 12, 22, 11] + [90] + []
Рекурсивный вызов для левой части...
Итог: [11, 12, 22, 25, 34, 64, 90]

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n log n)
  Когда опорный элемент всегда делит массив примерно пополам

- СРЕДНИЙ СЛУЧАЙ: O(n log n) 
  В большинстве практических ситуаций

- ХУДШИЙ СЛУЧАЙ: O(n²)
  Когда опорный элемент всегда минимальный или максимальный
  (например, массив уже отсортирован)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(n)
- Из-за рекурсивных вызовов и создания новых списков

ОБЪЯСНЕНИЕ BIG O:
- На каждом уровне рекурсии обрабатывается O(n) элементов
- Глубина рекурсии в среднем составляет O(log n) уровней
- Итого: O(n) × O(log n) = O(n log n)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


АЛГОРИТМ: СОРТИРОВКА ВЫБОРОМ (SELECTION SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм сортировки выбором находит минимальный элемент на каждой итерации и помещает его в начало неотсортированной части массива.

ШАГИ АЛГОРИТМА:
1. Находим минимальный элемент в неотсортированной части массива
2. Меняем его местами с первым элементом неотсортированной части
3. Увеличиваем границу отсортированной части на один элемент
4. Повторяем шаги 1-3 пока весь массив не будет отсортирован

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 25, 12, 22, 11]
Итерация 1: Найден минимальный 11 → [11, 25, 12, 22, 64]
Итерация 2: Найден минимальный 12 → [11, 12, 25, 22, 64]
Итерация 3: Найден минимальный 22 → [11, 12, 22, 25, 64]
Итерация 4: Найден минимальный 25 → [11, 12, 22, 25, 64]

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n²)
- СРЕДНИЙ СЛУЧАЙ: O(n²)
- ХУДШИЙ СЛУЧАЙ: O(n²)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
- Сортировка на месте, не требует дополнительной памяти

ОБЪЯСНЕНИЕ BIG O:
- Внешний цикл выполняется n-1 раз → O(n)
- Внутренний цикл выполняется в среднем n/2 раз → O(n)
- Итого: O(n) × O(n) = O(n²)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64
