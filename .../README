АЛГОРИТМ: БЫСТРАЯ СОРТИРОВКА (QUICK SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм быстрой сортировки работает по принципу "разделяй и властвуй":

1. ВЫБОР ОПОРНОГО ЭЛЕМЕНТА:
   - Выбирается опорный элемент (pivot), обычно последний элемент массива

2. РАЗДЕЛЕНИЕ МАССИВА:
   - Массив разделяется на три части:
     * LEFT: элементы МЕНЬШЕ опорного
     * MIDDLE: элементы РАВНЫЕ опорному  
     * RIGHT: элементы БОЛЬШЕ опорного

3. РЕКУРСИВНАЯ СОРТИРОВКА:
   - Рекурсивно применяется та же логика к левой и правой частям

4. ОБЪЕДИНЕНИЕ РЕЗУЛЬТАТОВ:
   - Отсортированные части объединяются в порядке: LEFT + MIDDLE + RIGHT

ПРОЦЕСС ПОВТОРЯЕТСЯ до базового случая - когда массив содержит 0 или 1 элемент.

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Опорный элемент: 90
Разделение: [64, 34, 25, 12, 22, 11] + [90] + []
Рекурсивный вызов для левой части...
Итог: [11, 12, 22, 25, 34, 64, 90]

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n log n)
  Когда опорный элемент всегда делит массив примерно пополам

- СРЕДНИЙ СЛУЧАЙ: O(n log n) 
  В большинстве практических ситуаций

- ХУДШИЙ СЛУЧАЙ: O(n²)
  Когда опорный элемент всегда минимальный или максимальный
  (например, массив уже отсортирован)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(n)
- Из-за рекурсивных вызовов и создания новых списков

ОБЪЯСНЕНИЕ BIG O:
- На каждом уровне рекурсии обрабатывается O(n) элементов
- Глубина рекурсии в среднем составляет O(log n) уровней
- Итого: O(n) × O(log n) = O(n log n)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


АЛГОРИТМ: СОРТИРОВКА ВЫБОРОМ (SELECTION SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм сортировки выбором находит минимальный элемент на каждой итерации и помещает его в начало неотсортированной части массива.

ШАГИ АЛГОРИТМА:
1. Находим минимальный элемент в неотсортированной части массива
2. Меняем его местами с первым элементом неотсортированной части
3. Увеличиваем границу отсортированной части на один элемент
4. Повторяем шаги 1-3 пока весь массив не будет отсортирован

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 25, 12, 22, 11]
Итерация 1: Найден минимальный 11 → [11, 25, 12, 22, 64]
Итерация 2: Найден минимальный 12 → [11, 12, 25, 22, 64]
Итерация 3: Найден минимальный 22 → [11, 12, 22, 25, 64]
Итерация 4: Найден минимальный 25 → [11, 12, 22, 25, 64]

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n²)
- СРЕДНИЙ СЛУЧАЙ: O(n²)
- ХУДШИЙ СЛУЧАЙ: O(n²)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
- Сортировка на месте, не требует дополнительной памяти

ОБЪЯСНЕНИЕ BIG O:
- Внешний цикл выполняется n-1 раз → O(n)
- Внутренний цикл выполняется в среднем n/2 раз → O(n)
- Итого: O(n) × O(n) = O(n²)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64

> Lesya:
// Тестовый массив
    vector<int> testArray = {64, 25, 12, 22, 11};
    
    cout << "Исходный массив: ";
    for (int num : testArray) cout << num << " ";
    cout << endl;
    
    // Сортируем массив
    selectionSort(testArray);
    
    cout << "Отсортированный массив: ";
    for (int num : testArray) cout << num << " ";
    cout << endl;
    
    return 0;
}

Файл: selection_sort_README.txt

АЛГОРИТМ: СОРТИРОВКА ВЫБОРОМ (SELECTION SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм сортировки выбором находит минимальный элемент на каждой итерации и помещает его в начало неотсортированной части массива.

ШАГИ АЛГОРИТМА:
1. Находим минимальный элемент в неотсортированной части массива
2. Меняем его местами с первым элементом неотсортированной части
3. Увеличиваем границу отсортированной части на один элемент
4. Повторяем шаги 1-3 пока весь массив не будет отсортирован

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 25, 12, 22, 11]
Итерация 1: Найден минимальный 11 → [11, 25, 12, 22, 64]
Итерация 2: Найден минимальный 12 → [11, 12, 25, 22, 64]
Итерация 3: Найден минимальный 22 → [11, 12, 22, 25, 64]
Итерация 4: Найден минимальный 25 → [11, 12, 22, 25, 64]

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n²)
- СРЕДНИЙ СЛУЧАЙ: O(n²)
- ХУДШИЙ СЛУЧАЙ: O(n²)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
- Сортировка на месте, не требует дополнительной памяти

ОБЪЯСНЕНИЕ BIG O:
- Внешний цикл выполняется n-1 раз → O(n)
- Внутренний цикл выполняется в среднем n/2 раз → O(n)
- Итого: O(n) × O(n) = O(n²)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64

---

АЛГОРИТМ 3: СОРТИРОВКА ПУЗЫРЬКОМ

Файл: bubble_sort.py

python
def bubble_sort(arr):
    """
    Функция сортировки пузырьком
    """
    n = len(arr)
    
    # Проходим по всем элементам массива
    for i in range(n - 1):
        # Флаг для оптимизации - если не было обменов, массив отсортирован
        swapped = False
        
        # Последние i элементов уже на своих местах
        for j in range(0, n - i - 1):
            # Сравниваем соседние элементы
            if arr[j] > arr[j + 1]:
                # Если порядок неправильный, меняем местами
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True  # Устанавливаем флаг обмена
        
        # Если не было обменов, массив отсортирован - выходим
        if not swapped:
            break

# Пример использования
if name == "main":
    # Тестовый массив
    test_array = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:", test_array)
    
    # Вызываем функцию сортировки
    bubble_sort(test_array)
    
    print("Отсортированный массив:", test_array)

Файл: bubble_sort_README.txt

АЛГОРИТМ: СОРТИРОВКА ПУЗЫРЬКОМ (BUBBLE SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм последовательно сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке. На каждой итерации самый большой элемент "всплывает" в конец массива.

ШАГИ АЛГОРИТМА:
1. Сравниваем первый и второй элемент, если нужно - меняем местами
2. Переходим к следующей паре (второй и третий элемент)
3. Повторяем до конца массива
4. Самый большой элемент оказывается в конце
5. Повторяем процесс для оставшейся части массива

ПРИМЕР РАБОТЫ:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Проход 1: 34, 25, 12, 22, 11, 64, 90
Проход 2: 25, 12, 22, 11, 34, 64, 90
Проход 3: 12, 22, 11, 25, 34, 64, 90
Проход 4: 12, 11, 22, 25, 34, 64, 90
Проход 5: 11, 12, 22, 25, 34, 64, 90

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n) - когда массив уже отсортирован
- СРЕДНИЙ СЛУЧАЙ: O(n²)
- ХУДШИЙ СЛУЧАЙ: O(n²) - когда массив отсортирован в обратном порядке

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
- Сортировка на месте, не требует дополнительной памяти

ОБЪЯСНЕНИЕ BIG O:
- Внешний цикл выполняется n-1 раз → O(n)
- Внутренний цикл выполняется в среднем n/2 раз → O(n)
- Итого: O(n) × O(n) = O(n²)
- В лучшем случае (с флагом swapped): O(n)

> Lesya:
ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

---

АЛГОРИТМ 4: СОРТИРОВКА ВСТАВКАМИ

Файл: insertion_sort.py

python
def insertion_sort(array):
    """
    Функция сортировки вставками
    """
    # Начинаем со второго элемента (индекс 1)
    for i in range(1, len(array)):
        # Сохраняем текущий элемент для вставки
        key = array[i]
        
        # Начинаем сравнение с предыдущим элементом
        j = i - 1
        
        # Перемещаем элементы, которые больше key, вправо
        while j >= 0 and array[j] > key:
            # Сдвигаем элемент вправо
            array[j + 1] = array[j]
            # Переходим к следующему элементу слева
            j = j - 1
        
        # Вставляем key на правильную позицию
        array[j + 1] = key

# Пример использования
if name == "main":
    # Тестовый массив
    array = [12, 11, 13, 5, 6]
    print("Исходный массив:", array)
    
    # Вызываем функцию сортировки
    insertion_sort(array)
    
    print("Отсортированный массив:", array)

Файл: insertion_sort_README.txt

АЛГОРИТМ: СОРТИРОВКА ВСТАВКАМИ (INSERTION SORT)

ОПИСАНИЕ РАБОТЫ:
Алгоритм строит отсортированную часть массива по одному элементу за раз. Каждый новый элемент вставляется в правильную позицию в уже отсортированной части.

ШАГИ АЛГОРИТМА:
1. Начинаем со второго элемента (считаем первый элемент отсортированным)
2. Сохраняем текущий элемент (key)
3. Сравниваем key с элементами в отсортированной части (слева)
4. Сдвигаем элементы больше key вправо
5. Вставляем key на найденную позицию
6. Повторяем для всех элементов

ПРИМЕР РАБОТЫ:
Исходный массив: [12, 11, 13, 5, 6]
Шаг 1: [11, 12, 13, 5, 6]  (вставка 11)
Шаг 2: [11, 12, 13, 5, 6]  (вставка 13)
Шаг 3: [5, 11, 12, 13, 6]  (вставка 5)
Шаг 4: [5, 6, 11, 12, 13]  (вставка 6)

АНАЛИЗ СЛОЖНОСТИ (BIG O):

ВРЕМЕННАЯ СЛОЖНОСТЬ:
- ЛУЧШИЙ СЛУЧАЙ: O(n) - когда массив уже отсортирован
- СРЕДНИЙ СЛУЧАЙ: O(n²)
- ХУДШИЙ СЛУЧАЙ: O(n²) - когда массив отсортирован в обратном порядке

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(1)
- Сортировка на месте, не требует дополнительной памяти

ОБЪЯСНЕНИЕ BIG O:
- Внешний цикл выполняется n-1 раз → O(n)
- Внутренний цикл в худшем случае выполняется i раз → O(n)
- Итого: O(n) × O(n) = O(n²)
- В лучшем случае внутренний цикл выполняется 1 раз → O(n)

ТЕСТИРОВАНИЕ:
Код протестирован в OnlineGDB. Результат:
Исходный массив: [12, 11, 13, 5, 6]
Отсортированный массив: [5, 6, 11, 12, 13]
